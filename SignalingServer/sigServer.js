const dgram = require('dgram');
const fs = require('fs');
const crypto = require('crypto');
const WebSocket = require('ws');
var ip = require('ip');
const si = require('systeminformation');
const publicIp = require('public-ip');

const debug = false;

//si.uuid().then(data => console.log(data));
var identifier;
var serverVars = {};
var reportedIP = null;
serverVars.listeningPort = 1097;
serverVars.reportedIP = null;

var lastIP;

function refreshReportedIp () {
  publicIp.v4().then(res => {
  if (debug) console.log("Reported IP address saved:", res);
    serverVars.reportedIP = res;
    if (lastIP != serverVars.reportedIP) {
      console.log("Announcing new IP", serverVars.reportedIP);
      lastIP = serverVars.reportedIP;
      announce({type: "IPREPORT", data: serverVars.reportedIP});
      if (verServer != null && verServer.readyState == 1) {
        verServer.send(JSON.stringify({type: "IPREPORT", data: serverVars.reportedIP}));
      }
    }
  }).catch(e => {
    if (debug) console.log("Failed to refresh Reported IP");
    serverVars.reportedIP = null;
    if (lastIP != serverVars.reportedIP) {
      console.log("Announcing new IP", serverVars.reportedIP);
      lastIP = serverVars.reportedIP;
      announce({type: "IPREPORT", data: serverVars.reportedIP});
      if (verServer != null && verServer.readyState == 1) {
        verServer.send(JSON.stringify({type: "IPREPORT", data: serverVars.reportedIP}));
      }
    }
  });
}

refreshReportedIp();
setInterval(refreshReportedIp, 60000);

//Get our keys if any or create a file for them
if (!fs.existsSync(__dirname + "/keys.json")) {
  try {
    fs.writeFileSync(__dirname + "/keys.json", "{}");
  } catch (e) {
    console.log("Error creating serverlog file, check file permissions. Error: " + e.code, e);
    process.exit(0);
  }
}

var keys;
try {
  keys = fs.readFileSync(__dirname + "/keys.json", 'utf8');
  keys = JSON.parse(keys);
} catch (e) {
  console.log("Error reading keys file, check the file and try again. Error: " + e.code, e);
  process.exit(0);
}

/*Private key encryption ex
privateKeyEncoding: {
  type: 'pkcs8',
  format: 'pem',
  cipher: 'aes-256-cbc',
  passphrase: 'top secret'
}
*/
//Key checking, if keys not generated, make some new ones
if (keys.private == null || keys.public == null) {
  console.log("Generating verification keypair");
  var k;
  try {
    k = crypto.generateKeyPairSync('ec', {
      namedCurve: "secp224r1",
      publicKeyEncoding: {
        type: 'spki',
        format: 'pem'
      },
      privateKeyEncoding: {
        type: 'pkcs8',
        format: 'pem'
      }
    });
  } catch (e) {
    console.log("Error generating keypair! ", e);
    process.exit(0);
  }
  keys.private = k.privateKey; //Store Globally
  keys.public = k.publicKey; //Store Globally

  //Save keypair
  fs.writeFileSync(__dirname + "/keys.json", JSON.stringify(keys));
  console.log("Created Keypair");
}
serverVars.keys = keys;

//Send object to all verified peers
function announce (o, connectability, ids) {
  if (ids == null) ids = [];
  for (i in peers) {
    if (ids.includes(peers[i].ident)) continue; //IDs is a list of IDs we should ignore
    if (peers[i].state == 3 && ((connectability == true && peers[i].connectability == 2) || (connectability == false || connectability == null))) {
      peers[i].socket.sendSign(o);
    }
  }
}

//We get the server's idendification using systeminformation and SHA256
//This identifier is based off the systems UUID generated by the OS during machine installation
si.uuid(function (r) {
    var h = r.hardware;
    if (h == "") h = r.os;
    if (h == "") {
      var str = ""
      for (i in r.macs) str += r.macs[i] + "|";
      h = str;
    }
    if (h == "") {
      console.log("ERROR, COULD NOT GENERATE UID, YOUR OS MAY NOT SUPPORT THIS FEATURE");
      process.exit(1);
    }
    serverVars.identifier = crypto.createHash('sha256').update(h+keys.public).digest('hex');
    console.log("Your identifier is: " + serverVars.identifier);

    if (selfVerify() == 1) ready();
    connectVServer();
});

//verification server address
var verificationAddress = "connect.gameslab.ca:1099";
var verServer;

serverVars.verified = null; //This controls the servers ability to operate correctly

//We use a serverLog file to keep track of host and verification data
if (!fs.existsSync(__dirname + "/serverLog.json")) {
  try {
    fs.writeFileSync(__dirname + "/serverLog.json", "{}");
  } catch (e) {
    console.log("Error creating serverlog file, check file permissions. Error: " + e.code, e);
    process.exit(0);
  }
}

var serverLogs;
try {
  serverLogs = fs.readFileSync(__dirname + "/serverLog.json", 'utf8');
  serverLogs = JSON.parse(serverLogs);
} catch (e) {
  console.log("Error reading serverlog file, check the file and try again. Error: " + e.code, e);
  process.exit(0);
}

//Catch any missing pieces of the serverlogs
if (serverLogs.verification == null) serverLogs.verification = {};
if (serverLogs.servers == null) serverLogs.servers = {};
fs.writeFileSync(__dirname + "/serverLog.json", JSON.stringify(serverLogs));

//This is a constant check to look for alive peers and connect with them
setInterval(searchForPeers, 1000);

var peers = {}; //List of connected peer SigServers
var clients = {}; //List of Connected clients

//We constantly check the connectability of clients when some don't pass the check
setInterval(function () {
  for (i in peers) {
    if (peers[i].state == 3 && peers[i].UDPping == null && peers[i].TCPping == null && peers[i].connectability != 2) {
      //If no pings in progress and connectabilty is failure state
      UDPPing(peers[i]);
      if (peers[i].socket.type == "sig") TCPPing(peers[i]);
    }
  }
}, 60000);

//Send peer data from ServerLogs to Peer
function updatePeer (peer) {
  var servers = [];
  //Grab all servers that act as valid candidates
  for (i in serverLogs.servers) {
    var server = serverLogs.servers[i];
    if (!ip.isPrivate(server.address) && (server.blocked == null || server.blocked < Date.now()) && server.state == 0) servers.push(server);
  }
  var o = {type: "PEERS", data: servers};
  peer.socket.sendSign(o);
}

//Peer connectability determination
//connectability: 0 = is private, 1 = node is public but not accessible, 2 = node is public and accessible
function pingRet (peer) {
  if (peer.UDPping == null || peer.TCPping == null) return;
  if (peer.UDPping.resp != null && peer.TCPping.resp != null) {
    if (peer.UDPping.resp == "VISIBLE" && peer.TCPping.resp == "VISIBLE" && !ip.isPrivate(peer.address)) {
      peer.connectability = 2;
      updatePeer(peer);
      var o = {type: "PEERS", data: [peer.server]};
      announce(o, true, [peer.ident]); //We avoid telling a node about itself by adding its ID to the ignore list
      if (debug) console.log("Peer is connectable!"); // This is when we should share peers with this node
    } else if (!ip.isPrivate(peer.address)) {
      peer.connectability = 1;
      //We tell the other peer we are having trouble with connecting to them
      peer.socket.sendSign({type: "REMOTEFAILURE"});
      if (debug) console.log("Peer is public but not connectable!");
    } else {
      peer.connectability = 0;
      if (debug) console.log("Peer is private!");
    }
    peer.UDPping = null;
    peer.TCPping = null;
  }
}

function UDPPing (peer) {
  if (debug) console.log("UDP Ping Test:", peer.ident);
  if (peer.UDPping != null) {
    peer.UDPping.stop();
    delete peer.UDPping;
  }
  var p = {};
  p.address = peer.address;
  p.port = peer.listeningPort;
  p.ident = peer.ident;
  p.client = dgram.createSocket('udp4');
  p.stop = function () {
    if (this.int) clearInterval(this.int);
    if (this.timeout) clearTimeout(this.timeout);
    this.int = null;
    this.timeout = null;
    this.client.close();
  }.bind(p);
  p.complete = function (resp) {
    if (debug) console.log("UDP Complete:", resp);
    this.UDPping.stop();
    this.UDPping.resp = resp;
    pingRet(this, resp);
  }.bind(peer);
  p.client.on('listening', function () {
    this.timeout = setTimeout(this.complete.bind(null, "TIMEOUT"), 7000);
    this.int = setInterval(this.send, 2000);
    this.send();
  }.bind(p));
  p.client.on("message", function (m,r) {
    if (r.address != this.address || r.port != this.port) return;
    try {
      m = JSON.parse(m.toString());
    } catch (e) {
      return;
    }
    if (debug) console.log(m);
    if (m.type == "IDENT" && m.ident != null && m.verification != null && m.signature != null) {
      if (m.ident != this.ident) return;
      var verif = verify(m.ident);
      if (verif == null || verif.status == false || registerNewVerif(m.verification) == -1) return;
      if (!verifySig(signatureStringifyer(m), verif.key, m.signature)) return;
      if (debug) console.log("UDP Ping test complete");
      this.complete("VISIBLE");
    }
  }.bind(p));
  p.send = function () {
    var msg = JSON.stringify({type: "IDENT"});
    msg = Buffer.from(msg); //Convert to required buffer format
    try {
      this.client.send(msg, this.port, this.address);
    } catch (e) {
      this.complete("ERR");
    }
  }.bind(p);
  p.client.bind(0);
  peer.UDPping = p;
}

function TCPPing (peer) {
  if (debug) console.log("TCP Ping Test:", peer.ident);
  if (peer.TCPping != null) {
    peer.TCPping.stop();
    delete peer.TCPping;
  }
  var ping = {};
  ping.socket = new WebSocket('ws://' + peer.address + ":" + peer.listeningPort);
  ping.open = function (e) {
    if (this.timeout != null) clearTimeout(this.timeout)
    this.timeout = null;
    this.socket.send(JSON.stringify({type: "IDENT"}));
  }.bind(ping);

  ping.error = function (e) {
    this.err = e;
  }.bind(ping);

  ping.close = function () {
    if (this.timeout != null) clearTimeout(this.timeout)
    this.timeout = null;
    if (this.err != null && (this.err.code == "ECONNREFUSED" || this.err.code == "ETIMEDOUT" || this.err.code == "ECONNRESET")) {
      this.complete("TIMEOUT");
    } else if (this.err != null && this.err.toString().indexOf("WebSocket was closed before the connection was established") == -1) {
      if (debug) console.log("TCP Complete:", this.err.code);
    }
  }.bind(ping)

  ping.complete = function (resp) {
    if (debug) console.log("TCP Complete:", resp);
    this.TCPping.stop();
    this.TCPping.resp = resp;
    pingRet(this, resp);
  }.bind(peer);

  ping.timeout = setTimeout(ping.complete.bind(null,"TIMEOUT"), 7000);

  ping.socket.on("open", ping.open.bind(ping));
  ping.socket.on("close", ping.close.bind(ping));
  ping.socket.on("error", ping.error.bind(ping));
  ping.socket.on("message", function (m) {
    try {
      m = JSON.parse(m.toString());
    } catch (e) {
      return;
    }
    //console.log(m);
    if (m.type == "IDENT" && m.ident != null && m.verification != null && m.signature != null) {
      if (m.ident != this.ident) return;
      var verif = verify(m.ident);
      if (verif == null || verif.status == false || registerNewVerif(m.verification) == -1) return;
      if (!verifySig(signatureStringifyer(m), verif.key, m.signature)) return;
      if (debug) console.log("TCP Ping test complete");
      this.socket.close();
      this.complete("VISIBLE");
    }
  }.bind(ping));

  ping.stop = function () {
    if (this.timeout != null) clearTimeout(this.timeout)
    this.timeout = null;
    try {
      this.socket.close();
    } catch (e) {
      return;
    }
  }.bind(ping);

  peer.TCPping = ping;
}

//add or update a peer to the serverLogs
function registerPeer (server) {
  if (server.id == serverVars.identifier) return; //Don't add ourselves to the list
  if (debug) console.log("New Peer found:", server.id);
  if (serverLogs.servers[server.id] != null) {
    var s = serverLogs.servers[server.id];
    if (s.lastConnection < server) {
      serverLogs.servers[server.id] = server;
    }
  } else {
    serverLogs.servers[server.id] = server;
  }
  fs.writeFileSync(__dirname + "/serverLog.json", JSON.stringify(serverLogs));
}

//Search for peers code
function searchForPeers () {
  //We don't serarch if we aren't verified and don't have keys
  if (serverLogs.publicKey == null || serverVars.verified == null) return;

  //We use a variable 'servers' to store a list of possible servers to connect to
  var servers = [];
  //We poll from our list of known servers
  for (i in serverLogs.servers) servers.push(serverLogs.servers[i]);
  //And sort them by their reliability
  servers.sort(function (a,b) {return a.failedConnectAttempts-b.failedConnectAttempts;});

  //This is where we filter out candidates that may be best suited
  var targetServer;
  for (i in servers) {
    var server = servers[i];
    if (server.blocked != null) if (server.blocked > Date.now()) continue; //No blocked servers allowed
    if (server.state == 1) continue; //don't connect to peers we determined to be dead, 1 == dead, 0 == known good
    if (peers[server.id] != null) continue; //Don't connect to nodes we already have a connection with
    targetServer = server; //Save our top pick server
    break;
  }

  //If no other options still
  if (targetServer == null) {
    for (i in servers) {
      var server = servers[i];
      if (server.blocked != null) if (server.blocked > Date.now()) continue; //Still don't like blocked hosts
      if (server.state == 0) continue; //We then decide to try hosts that are knon down
      if (peers[server.id] != null) continue;
      targetServer = server; //Save the target
      break;
    }
  }
  if (targetServer == null) return;
  connectTo(server); //Try connecting to that peer
}

//Try to use known data to verify yourself in case the verification server is down
function selfVerify () {
  if (!serverLogs.publicKey) return -3; //No stored public key for the verifcation server, don't even bother

  var highest = null;
  //For each verification we want to find the most recent signature for our IDENT code
  for (i in serverLogs.verification) {
    var verif = serverLogs.verification[i];
    if (verif.ident == serverVars.identifier && keys.public == verif.key) {
      if (highest == null) highest = verif;
      if (verif.verificationID > highest.verificationID) highest = verif;
    }
  }
  if (highest == null) return -1; //No signature from the verification server was found for us, fail
  else {
    //Check the verification entry public key matches our own private key signature
    if (verifySig("verify", highest.key, keySign("verify"))) {
      //Check the verification entry is geniune from the verification server
      if (verifySig(signatureStringifyer(highest), serverLogs.publicKey, highest.signature)) {
        if (!highest.status) return -5; //This is when the verifiction server revoked our verified status.
        serverVars.verified = highest;
        console.log("Self Verification confirmed!");
        return 1;
      } else {
        return -4; //Verification entry is not geniune
      }
    } else {
      return -2; //public key missmatch
    }
  }
}

//This is used to store newly discovered peers to serverLog, only used for verification server peers, not other kinds
function addPeer (s) {
  if (s.id == null || s.ip == null || s.port == null) return -2;
  if (serverLogs.servers[s.id] != null && serverLogs.servers[s.id].id != null && serverLogs.servers[s.id].id == s.id) {
    if (serverLogs.servers[s.id].address != s.ip || serverLogs.servers[s.id].port != s.port) {
      var o = {address: s.ip, port: s.port, state: 0, lastConnection: serverLogs.servers[s.id].lastConnection, failedConnectAttempts: 0, id: s.id};
      serverLogs.servers[s.id] = o;
      fs.writeFileSync(__dirname + "/serverLog.json", JSON.stringify(serverLogs));
      return 2;
    } else {
      return -1;
    }
  }
  var o = {address: s.ip, port: s.port, state: 0, lastConnection: null, failedConnectAttempts: 0, id: s.id};
  serverLogs.servers[s.id] = o;
  fs.writeFileSync(__dirname + "/serverLog.json", JSON.stringify(serverLogs));
  return 1;
}

//Connect to a peer
function connectTo (server) {
  if (debug) console.log("Connecting to " + server.id);
  //State: 0 = connecting, 1 = Authenticating, 2 = second auth, 3 = connected, 4 = closed, 5 = closing
  var peer = {server: server, ident: server.id, state: 0, connectability: 0, time: new Date().getTime()};
  peer.socket = new WebSocket('ws://' + server.address + ":" + server.port);

  peer.socket.on("open", onPeerOpen.bind(peer));
  peer.socket.on("close", onPeerClose.bind(peer));
  peer.socket.on("error", onPeerError.bind(peer));
  peer.socket.on("message", onPeerResp.bind(peer));

  peer.address = server.address;

  peer.pingTimeoutCount = 0;

  peer.socket.sendSign = function (m) {
  if (this.socket.readyState != 1) return;
    m.signature = keySign(signatureStringifyer(m));
    this.socket.send(JSON.stringify(m));
  }.bind(peer);

  peer.close = function () {
    if (this.state == 4) return -1; //Connection already closed

    //try forcing the connection closed
    try {
      this.socket.close();
    } catch (e) {
      return;
    }

    if (peers[this.ident] != null && peers[this.ident].time == this.time) delete peers[this.ident];
  }

  peers[server.id] = peer;
}

function onPeerOpen () {
  this.state = 1; //Authenticating

  //When we connect to a peer we identify ourselves
  var o = {verif: serverVars.verified, type: "SIGSERVERCON", ident: serverVars.identifier, port: serverVars.listeningPort, reported: serverVars.reportedIP};
  this.socket.sendSign(o);
  this.TCPping = {};
  this.TCPping.resp = "VISIBLE"; //We just connected to the node, so we already know its acessible
}

function onPeerClose () {
  if (!this.err && this.state != 5) console.log("Peer Connection lost", this.ident);
  if (this.err == "CLOSEBEFOREEST" && debug) console.log("Connection to peer canceled:", this.ident);

  if (this.int != null) {
    clearInterval(this.int);
    this.int = null;
  }

  if (this.timeout != null) {
    clearTimeout(this.timeout);
    this.timeout = null;
  }

  if (this.UDPping != null && this.UDPping.resp == null) this.UDPping.stop();

  if (this.TCPping != null && this.TCPping.resp == null) this.TCPping.stop();

  this.state = 4;
  if (peers[this.ident] != null && peers[this.ident].time == this.time) delete peers[this.ident];
}

function onPeerError (e) {
  this.err = e.code;
  if (e.code == "ECONNREFUSED" || e.code == "ETIMEDOUT") {
    if (debug) console.log("Connection failed to peer:", this.ident);
  } else if (e.toString().indexOf("WebSocket was closed before the connection was established") > -1) {
    this.err = "CLOSEBEFOREEST";
  } else {
    console.log("Peer connection error:", e);
  }
}

function onPeerResp (m) {
  try {
    m = JSON.parse(m);
  } catch (e) {
    return this.close();
  }
  //console.log(m);
  if (this.verified && !verifySig(signatureStringifyer(m), this.verified.key, m.signature)) return;
  if (m.type == "VERIF") {
    //This is where we handle verification messages from the server, this is were it tells us whether it accepts us or not
    if (m.data == "PASS" && m.ident != null && m.verification != null && m.signatures != null && m.signature != null && m.port != null) {
      //We connected sucessfuly and it has verified our identity, now we check its verification
      if (registerNewVerif(m.verification) == -1) {
        //Non-genuine verification sent
        this.socket.sendSign({type: "SIGSERVERRESP", key: keys.public, ident: serverVars.identifier, verif: verif, data: "FAILREJ"});
        return this.close();
      }

      var verif = verify(m.ident);

      if (verif != null && verif.status) {
        if (!verifySig(signatureStringifyer(m), verif.key, m.signature)) {
          //If the key we have stored can't match the signature of the message we got we disconnect them
          this.socket.sendSign({type: "SIGSERVERRESP", data: "SIGFAIL"});
          return this.close();
        }

        this.verified = verif;

        var resp = {type: "SIGSERVERRESP", data: "PASS", signatures: len(serverLogs.verification)};

        if (m.signatures > len(serverLogs.verification)) {
          //Peer has more data
          var arr = verificationUpTo(m.signatures-1); //we also check and compare our verification entry array with the server
          if (arr.length > 0) this.socket.sendSign({type: "REQAUDITS", arr: arr}); //Send our array to the server
        } else if (m.signatures < len(serverLogs.verification)) {
          //We have more data, pass it along
          var arr = [];
          for (var i = m.signatures-1; i < len(serverLogs.verification); i++) {
            arr.push(serverLogs.verification[i]);
          }
          resp.verifAudit = arr;
        }

        this.socket.sendSign(resp);

        serverLogs.servers[verif.ident].lastConnection = Date.now();
        serverLogs.servers[verif.ident].failedConnectAttempts = 0;
        serverLogs.servers[verif.ident].state = 0;
        serverLogs.servers[verif.ident].port = m.port;

        if (ip.isPrivate(this.address) && m.reported != null && !ip.isPrivate(m.reported)) this.address = m.reported;
        serverLogs.servers[verif.ident].address = this.address;
        this.listeningPort = m.port; //and listening port

        fs.writeFileSync(__dirname + "/serverLog.json", JSON.stringify(serverLogs));

        this.int = setInterval(function () {
          if (this.timeout != null) return;
          this.socket.sendSign({type: "PING"});
          this.timeout = setTimeout(function () {
            this.timeout = null;
            this.pingTimeoutCount++;
            if (debug) console.log(this.ident, "Peer Timeout! - " + this.pingTimeoutCount);
            if (this.pingTimeoutCount > 3) this.socket.close();
          }.bind(this), 5000);
        }.bind(this), 1000);

        //Start testing the UDP socket of the peer
        UDPPing(this);
        //We don't test TCP because we already know its working

        console.log("Connected to verified peer: " + verif.ident);
        this.state = 3;

      } else if (verif.status == false) {
        //If this nodes most recent verification entry is a revoked status, we can't accept this connection
        //cause the verification server has revoked its verification
        this.socket.sendSign({type: "SIGSERVERRESP", verif: verif, data: "FAILREJ"});
        return this.close();
      } else {
        //This node is not known to us and its verification didn't match, this is unlikely to occur but is a catch just in case
        this.socket.sendSign({type: "VERIF", ident: serverVars.identifier, data: "FAILUNK"});
        return this.close();
      }
    } else {
      if (debug) console.log("Connection Failed, Peer rejected Auth:", m);
      if (m.verif != null) {
        registerNewVerif(m.verif);
        if (selfVerify() == -5) {
          serverVars.verified = null;
          console.log("WARNING: This node is not verified and may not be able to interact with the network. Please check verification status.");
        }
      }
      if (m.data == "FAILSELF") {
        if (debug) console.log("Node connected to itself");
        this.close();
      } else if (m.data == "SIGFAIL") {
        if (debug) console.log("Node failed to check our signature");
        this.close();
      } else if (m.data == "FAILREJ") {
        if (debug) console.log("Node refused our verification, check verification status");
        this.close();
      } else if (m.data == "FAILUNK") {
        if (debug) console.log("Node appears to be part of a different network, check verification server keys");
        this.close();
      } else if (m.data == "CONINPROG") {
        if (debug) console.log("Node refused our connection, another node of that identifier is already connected");
        this.close();
      }
    }
  } else if (m.type == "PING") {
    this.socket.sendSign({type: "PONG"});
  } else if (m.type == "PONG" && this.timeout != null) {
    clearTimeout(this.timeout);
    this.timeout = null;
    this.pingTimeoutCount = 0;
  } else if (m.type == "IPREPORT") {
    if (ip.isPrivate(this.address) && m.data != null && !ip.isPrivate(m.data)) this.address = m.data;

    serverLogs.servers[this.ident].address = this.address;
    fs.writeFileSync(__dirname + "/serverLog.json", JSON.stringify(serverLogs));

    this.connectability = 0;
    UDPPing(this.peerObj);
    TCPPing(this.peerObj);
  } else if (m.type == "REMOTEFAILURE") {
    console.log("WARNING: It appears your server is inaccessible. Please check your port forwarding or firewalls to ensure TCP&UDP port " + serverVars.listeningPort + " is open");
  } else if (m.type == "PEERS") {
    for (i in m.data) registerPeer(m.data[i]);
  } else if (m.type == "CLIMESS") {
    onCliForward(m, this.verified.ident);
  } else {
    console.log("Unknown Message", m);
  }
}

//Grabs existing public key for host
function verify (hostID) {
  var highest = null;
  for (i in serverLogs.verification) {
    if (serverLogs.verification[i].ident == hostID && highest == null) highest = serverLogs.verification[i].verificationID;
    if (serverLogs.verification[i].ident == hostID && serverLogs.verification[i].verificationID > highest) highest = serverLogs.verification[i].verificationID;
  }
  if (highest == null) return;
  return serverLogs.verification[highest];
}

//Verifies data vs a signature using a provided key
function verifySig (data, key, signature) {
  const verifier = crypto.createVerify('RSA-SHA256');
  verifier.write(data);
  verifier.end();
  return verifier.verify(key, signature, 'base64');
}

//parse verification entry and make necessary changes if valid and verified
function registerNewVerif (v) {
  if (!serverLogs.publicKey) return -2; //Central server unknown
  if (serverLogs.verification[v.verificationID] != null) return -3; //verification already exists
  if (!verifySig(signatureStringifyer(v), serverLogs.publicKey, v.signature)) return -1; //Invalid Signature
  serverLogs.verification[v.verificationID] = v; //Save it
  fs.writeFileSync(__dirname + "/serverLog.json", JSON.stringify(serverLogs)); //Write it
}

//Write the data with the server's private key
function keySign (data) {
  const signer = crypto.createSign('RSA-SHA256');
  signer.write(data);
  signer.end();
  return signer.sign(keys.private, 'base64');
}

//Converts json objects to strings without signatures, helps with generating signatures and verification
function signatureStringifyer (o) {
  var string = "";
  for (i in o) if (i != "signature" && i != "sourceSignature" && o[i] != null) string += o[i].toString();
  return string;
}

//Gets the entire verification entry array up to a highest point of time
function verificationUpTo (highest) {
  var arr = [];
  for (var i = 0; i <= highest; i++) if (serverLogs.verification[i] == null) arr.push(i);
  return arr;
}

//Connect to verification server
function connectVServer () {
  if (verServer != null) return; //if already connected, don't continue

  //Create new socket for connecting
  verServer = new WebSocket('ws://' + verificationAddress);

  //When connected
  verServer.on("open", function () {

    //Create our sendSign function so we can send objects with signatures
    verServer.sendSign = function (m) {
      m.signature = keySign(signatureStringifyer(m));
      verServer.send(JSON.stringify(m));
    }
    //console.log("Connected to verification server!");

    //Send the expected message to the signal server to identify ourselves
    var o = {type: "SIGSERVER", ident: serverVars.identifier, port: serverVars.listeningPort, key: keys.public, reported: serverVars.reportedIP};
    verServer.sendSign(o);
  });

  //Set our verification server message handler
  verServer.on("message", onVServerMess);

  //On errors
  verServer.on("error", function (e) {
    verServer.err = true; //This helps block some functions so errors don't occur
    if (e.code == "ECONNREFUSED" || e.code == "ETIMEDOUT") {
      if (debug) console.log("Failed to connect to Verification Server");
    } else console.log("Verification Server error", e);
  });

  //When verification server is lost
  verServer.on("close", function () {
    if (!verServer.err) console.log("Verification server lost");
    if (verServer.int != null) clearInterval(verServer.int);
    if (verServer.intInProg != null) clearTimeout(verServer.intInProg);
    verServer = null;
    setTimeout(connectVServer, 5000); //Reconnect after 5 seconds
  });
}

var verErr = false;

//On Verification message
function onVServerMess (m) {
  //We make sure we're dealing with objects, if errors we disconnect because thats sus
  try {
    m = JSON.parse(m);
  } catch (e) {
    return verServer.close();
  }

  //Make sure the messages the server sends match what we expect from the verification server key
  if (serverLogs.publicKey != null) if (!verifySig(signatureStringifyer(m), serverLogs.publicKey, m.signature)) return this.close();
  if (m.type == "VERIF") {
    //This is where we handle verification messages from the server, this is were it tells us whether it accepts us or not
    if (m.data == "PASS") {
      //We connected sucessfuly and it has verified our identity
      verErr = false;
      serverVars.verified = m.verification; //Store our verification info
      registerNewVerif(m.verification); //Register this verification if its new
      console.log("Verification confirmed!");

      verServer.int = setInterval(function () {
        if (verServer.intInProg != null) return;
        verServer.intInProg = setTimeout(function () {
          verServer.intInProg = null;
          if (debug) console.log("Verification Server Timeout");
          verServer.close();
        }.bind(this), 5000);
        this.sendSign({type: "PING"});
      }.bind(this), 1000);

      ready(); //We are ready to operate
      this.sendSign({type: "REQNODES"}); //Request known nodes from the server
      var arr = verificationUpTo(m.signatures-1); //we also check and compare our verification entry array with the server
      if (arr.length > 0) this.sendSign({type: "REQAUDITS", arr: arr}); //Send our array to the server
    } else {
      //The server doesn't like our indentification and rejected us
      serverVars.verified = null;

      if (!verErr) {
        verErr = true;
        console.log("WARNING: This server has not been verified, and may not be able to connect to peers!");
        console.log("Server will continue rechecking verification every 5 seconds");
        console.log("Server Error Response:", m.data);
      }

      //At this point the server diconnects us automatically after this but we might as well do the same
      verServer.close();
    }

    //The verification server also provides us with its public key most times, so we make sure that is stored
    if (serverLogs.publicKey == null && m.key != null) {
      serverLogs.publicKey = m.key;
      fs.writeFileSync(__dirname + "/serverLog.json", JSON.stringify(serverLogs));
    }
  } else if (m.type == "NODES") {
    //When the server sends us its connected nodes we store them
    for (i in m.arr) addPeer(m.arr[i]);
  } else if (m.type == "AUDITS") {
    //When the server sends us back info for verification entries we store them
    var x = 0;
    for (i in m.arr) if (registerNewVerif(m.arr[i]) == 1) x++;
    if (debug) console.log("Synced " + x + " new entries with Central Server");
  } else if (m.type == "PONG" && verServer.intInProg != null) {
    clearTimeout(verServer.intInProg);
    verServer.intInProg = null;
  }
}

let udpServer;
let wsServer;

//This is where our UDP listening server is created
function prepSocket () {
  udpServer = dgram.createSocket({
    type: 'udp4',
    reuseAddr: true
  });
  udpServer.bind(serverVars.listeningPort); //Bind our port
  udpServer.on('message', onUDP); //As message handler
}

//This is where our WS server is setup
function prepServer () {
  wsServer = new WebSocket.Server({port: serverVars.listeningPort, host: "0.0.0.0"});
  wsServer.on("connection", onWebsocConn);
}

var started = false; //Helps block certain code from causing errors under certain states

//Called when we are ready to begin operating, usually only happens when we are verified
function ready () {
  if (started) return; //blocking us from creating multiple servers
  if (debug) console.log("Opening Servers");
  started = true;
  prepSocket(); //See function above
  prepServer(); //See function above
}

//Close our servers
function closeSockets () {
  if (!started) return;
  started = false;
  udpServer.close();
  udpServer = null;
}

//UDP message handler, this is usually going to be for clients connecting or peer servers checking our server status
function onUDP (m,r) {
  if (keys.private == null || keys.public == null || serverLogs.publicKey == null || serverVars.verified == null) return; //Don't handle connections without keys

  try {
    m = JSON.parse(m.toString());
  } catch (e) {
    return;
  }
  if (m.type == "IDENT") {
    var o = {type: "IDENT", ident: serverVars.identifier, verification: serverVars.verified};
    o.signature = keySign(signatureStringifyer(o));
    o = Buffer.from(JSON.stringify(o));
    udpServer.send(o, r.port, r.address);
  } else if (m.type == "CLIREQ") {
    var o = {type: "CLIRESP", ident: serverVars.identifier, verification: serverVars.verified, respPort: r.port, respAddress: r.address, reported: serverVars.reportedIP};
    o.signature = keySign(signatureStringifyer(o));
    o = Buffer.from(JSON.stringify(o));
    udpServer.send(o, r.port, r.address);
  } else if (m.type == "CLIPING") {
    var o = {type: "PONG"};
    o = Buffer.from(JSON.stringify(o));
    udpServer.send(o, r.port, r.address);
  } else {
    console.log("UDP:", m, r);
  }
}

function createRecPeer (socket, server) {
  var peer = {server: server, ident: server.id, state: 2, connectability: 0, time: new Date().getTime()};
  peer.socket = socket;
  peer.verified = socket.authed;
  peer.address = socket.address;

  peer.pingTimeoutCount = 0;

  peer.close = function () {
    if (this.state == 4) return -1; //Connection already closed
    this.state == 4;
    if (this.state == 2 && debug) console.log("Peer failed to respond for 2nd verification, timed out.");

    if (this.int != null) {
      clearInterval(this.int);
      this.int = null;
    }

    if (this.timeout != null) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }

    if (this.UDPping != null && this.UDPping.resp == null) this.UDPping.stop();

    if (this.TCPping != null && this.TCPping.resp == null) this.TCPping.stop();

    if (!this.err && this.state != 5 && debug) console.log("Peer Connection Closed:", this.ident);
    //try forcing the connection closed
    try {
      this.socket.close();
    } catch (e) {
      if (e.toString().indexOf("WebSocket was closed before the connection was established") == -1) xonsole.log(e);
    }
    if (peers[this.ident] != null && peers[this.ident].time == this.time) delete peers[this.ident];
  }.bind(peer);

  return peer;
}

//When we recieve a ws message
function onWebSoc (m) {
  //We don't allow this to function without our own keys as well as the verification server key saved
  if (serverVars.verified == null || serverLogs.publicKey == null) return this.close();

  //Make sure we are working with objects only, otherwise scrap the connection for being no conforming
  try {
    m = JSON.parse(m);
  } catch (e) {
    return this.close();
  }
  if (this.authed == null) {
    //Unauthorized connections are dealt with here

    //If sigServer tries to identify itself we make sure the message has required variables
    if (m.type == "SIGSERVERCON" && m.ident != null && m.verif != null && m.signature != null && m.port != null) {
      if (m.ident == serverVars.identifier || m.verif.ident == identifier) {
        //block connections from yourself if they occur
        this.sendSign({type: "VERIF", key: keys.public, ident: serverVars.identifier, verif: serverVars.verified, data: "FAILSELF"});
        return this.close();
      }

      //Don't accept dupicate connections
      if (peers[m.ident] != null && peers[m.ident].state == 3) {
        this.sendSign({type: "VERIF", key: keys.public, ident: serverVars.identifier, verif: serverVars.verified, data: "CONINPROG"});
        return this.close();
      }

      //We check the verification entry that the client is connecting with to see if its geniune
      if (registerNewVerif(m.verif) == -1) {
        //Non-genuine verification sent
        this.sendSign({type: "VERIF", key: keys.public, ident: serverVars.identifier, verif: serverVars.verified, data: "FAILREJ"});
        return this.close();
      }

      //Next we get our stored verification for this client
      var verif = verify(m.ident);

      //and check that this clients verification is still valid in our books
      if (verif != null && verif.status) {
        if (!verifySig(signatureStringifyer(m), verif.key, m.signature)) {
          //If the key we have stored can't match the sigtaure of the message we got we disconnect them
          this.sendSign({type: "VERIF", key: keys.public, ident: serverVars.identifier, verif: serverVars.verified, data: "SIGFAIL"});
          return this.close();
        }

        //If we got a connection from a node we are already connecting to, we cancel that second connection since we already linked
        if (peers[m.ident] != null) peers[m.ident].close();

        this.authed = verif; //Store verification entry
        this.type = "sig";//Label this connection as a signalling server

        server = serverLogs.servers[verif.ident];

        //Store the peer in our peers list
        peers[verif.ident] = createRecPeer(this, server);
        this.peerObj = peers[verif.ident];

        this.peerObj.listeningPort = m.port; //and listening port

        this.peerObj.address = this.ipAddress;
        if (ip.isPrivate(this.ipAddress) && m.reported != null && !ip.isPrivate(m.reported)) this.peerObj.address = m.reported;

        //Send notice that we accepted their connection
        this.sendSign({type: "VERIF", data: "PASS", ident: serverVars.identifier, port: serverVars.listeningPort, verification: serverVars.verified, signatures: len(serverLogs.verification), reported: serverVars.reportedIP});

        //Make sure our peer list is updated with this data
        var server = serverLogs.servers[verif.ident];
        if (server == null) addPeer({ip: this.address, port: this.listeningPort, id: verif.ident});
        serverLogs.servers[verif.ident].lastConnection = Date.now();
        serverLogs.servers[verif.ident].failedConnectAttempts = 0;
        serverLogs.servers[verif.ident].state = 0;
        serverLogs.servers[verif.ident].port = m.port;
        serverLogs.servers[verif.ident].address = this.peerObj.address;
        fs.writeFileSync(__dirname + "/serverLog.json", JSON.stringify(serverLogs));
        console.log("Verified peer: " + verif.ident);

      } else if (verif != null && verif.status == false) {
        //If this nodes most recent verification entry is a revoked status, we can't accept this connection
        //cause the verification server has revoked its verification
        this.sendSign({type: "VERIF", ident: serverVars.identifier, verif: verif, data: "FAILREJ"});
        serverLogs.servers[verif.ident].blocked = Date.now() + (60000*5); // block this node for 5 minutes
        fs.writeFileSync(__dirname + "/serverLog.json", JSON.stringify(serverLogs));
        return this.close();
      } else {
        //This node is not known to us and its verification didn't match, this is unlikely to occur but is a catch just in case
        this.sendSign({type: "VERIF", ident: serverVars.identifier, data: "FAILUNK"});
        return this.close();
      }
    } else if (m.type == "CLIENT" && m.ident != null) {
      clearTimeout(this.timeout);
      this.timeout = null;

      var nodes = [];
      for (i in peers) {
        if (peers[i].connectability == 2 && peers[i].state == 3) nodes.push(peers[i].server);
      }

      var o = {type: "IDENT", verif: serverVars.verified, nodes: nodes};

      o.identifier = crypto.createHash('shake128').update(m.ident + Date.now()).digest('hex');
      o.ident = serverVars.identifier;
      o.key = keys.public;
      this.sendSign(o);
      var client = {ident: o.identifier};
      client.socket = this;
      this.authed = "cli";
      this.cliObj = client;
      clients[o.identifier] = client;
      this.pingInt = setInterval(function () {
        if (this.pingTimeout == null) {
          this.pingTimeout = setTimeout(function () {
            if (this.pingTimeout == null) return;
            this.pingTimeout = null;
            this.close();
          }.bind(this), 5000);
        }
        this.sendSign({type: "PING"});
      }.bind(this), 1000);
    } else if (m.type == "IDENT") {
      var o = {type: "IDENT", ident: serverVars.identifier, verification: serverVars.verified};
      this.sendSign(o);
    } else {
      //Messages we don't know are grounds for connection termination
      console.log("UNKNOWN MESS:", m);
      this.close();
    }
  } else {
    //Authorized connections here

    if (this.authed == "cli") return onCliMess(m, this);

    if (!verifySig(signatureStringifyer(m), this.authed.key, m.signature)) return; //Ignore messages that don't seem legit

    if (m.type == "SIGSERVERRESP") {
      //when the client gets back to us about our verification
      if (m.verif != null) {
        registerNewVerif(m.verif);
        if (selfVerify() == -5) {
          serverVars.verified = null;
          console.log("WARNING: This node is not verified and may not be able to interact with the network. Please check verification status.");
        }
      }
      if (m.data == "FAILREJ") {
        if (debug) console.log("Client Rejected our verification");
        this.close();
        this.peerObj.state = 4;
      } else if (m.data == "SIGFAIL") {
        if (debug) console.log("Client failed to verify our signature, check key files for errors");
        this.close();
        this.peerObj.state = 4;
      } else if (m.data == "PASS") {
        console.log("Verified peer connected:", this.peerObj.ident);
        if (m.verifAudit != null) for (i in m.verifAudit) registerNewVerif(m.verifAudit[i]);
        this.peerObj.state = 3;
        this.peerObj.int = setInterval(function () {
          if (this.timeout != null) return;
          this.socket.sendSign({type: "PING"});
          this.timeout = setTimeout(function () {
            this.timeout = null;
            this.pingTimeoutCount++;
            if (debug) console.log(this.ident, "Peer Timeout! - " + this.pingTimeoutCount);
            if (this.pingTimeoutCount > 3) this.socket.close();
          }.bind(this), 5000);
        }.bind(this.peerObj), 1000);
        clearTimeout(this.timeout); //We don't need a timeout function anymore
        this.timeout = null;

        //Test the client connectivity
        UDPPing(this.peerObj);
        TCPPing(this.peerObj);
      } else if (m.data == "FAILUNK") {
        console.log("Node appears to be part of a different network, check verification server keys");
        this.close();
        this.peerObj.state = 4;
      }
    } else if (m.type == "PING") {
      this.sendSign({type: "PONG"});
    } else if (m.type == "PONG" && this.peerObj.timeout != null) {
      clearTimeout(this.peerObj.timeout);
      this.peerObj.timeout = null;
      this.peerObj.pingTimeoutCount = 0;
    } else if (m.type == "IPREPORT") {
      this.peerObj.address = this.ipAddress;
      if (ip.isPrivate(this.ipAddress) && m.data != null && !ip.isPrivate(m.data)) this.peerObj.address = m.data;

      serverLogs.servers[this.peerObj.ident].address = this.peerObj.address;
      fs.writeFileSync(__dirname + "/serverLog.json", JSON.stringify(serverLogs));

      this.peerObj.connectability = 0;
      UDPPing(this.peerObj);
      TCPPing(this.peerObj);
    } else if (m.type == "REMOTEFAILURE") {
      console.log("WARNING: It appears your server is inaccessible. Please check your port forwarding or firewalls to ensure TCP&UDP port " + serverVars.listeningPort + " is open");
    } else if (m.type == "PEERS") {
      for (i in m.data) registerPeer(m.data[i]);
    } else if (m.type == "CLIMESS") {
      onCliForward(m, this.authed.ident);
    } else {
      console.log("Unknown Message", m);
    }
  }
}

//When we receive a CLIREQ
function onCliForward (m, source) {
  var id = cliMessId(m);
  if (cliMesses.includes(m.requestID)) return;
  if (clients[m.destination] != null) {
    clients[m.destination].socket.sendSign(m);
    //console.log(m.source + " => " + m.destination + ":", m);
  } else {
    //console.log("Forwarding to servers");
    pushCliMess(id);
    announce(m, false, [source]);
    //Push it to the network
  }
}

function SHA256 (text) {
  var shasum = crypto.createHash("sha256");
  shasum.update(text);
  return shasum.digest('hex');
}

function cliMessId (o) {
  var t = o.data+o.source+o.destination+o.dateStamp
  return SHA256(t);
}

function onCliMess(m, socket) {
  //console.log(m);
  if (m.type == "PING") {
    socket.sendSign({type: "PONG"});
  } else if (m.type == "PONG") {
    if (socket.pingTimeout != null) clearTimeout(socket.pingTimeout);
    socket.pingTimeout = setTimeout(function () {
      if (this.pingTimeout == null) return;
      this.pingTimeout = null;
      this.close();
    }.bind(socket), 5000);
  } else if (m.type == "CLIMESS") {
    m.source = socket.cliObj.ident;
    if (clients[m.destination] != null) {
      clients[m.destination].socket.sendSign(m);
      //console.log(m.source + " => " + m.destination + ":", m);
    } else {
      m.sourceServer = serverVars.identifier;
      m.dateStamp = Date.now();
      var requestID = cliMessId(m);
      pushCliMess(requestID);
      announce(m);
      //console.log("Pushing to network");
      //Push it to the network
    }
  }
}

var cliMesses = [];
function pushCliMess (id) {
  cliMesses.push(id);
  if (cliMesses.length > 10000) cliMesses.shift();
}

//When we receive a ws connection
function onWebsocConn (ws, req) {
  if (keys.private == null || keys.public == null || serverLogs.publicKey == null || serverVars.verified == null) return ws.close(); //Don't handle connections without keys

  //We timeout connections that take too long to identify themselves
  ws.timeout = setTimeout(function () {
    this.close();
  }.bind(ws), 1500);

  //Store the IP address information
  ws.ipAddress = req.socket.remoteAddress;

  //Setup our function for sending signed messasges
  ws.sendSign = function (m) {
    //console.log(m);
    if (this.readyState != 1) return;
    m.signature = keySign(signatureStringifyer(m));
    ws.send(JSON.stringify(m));
  }

  //Connection close handler
  ws.on("close", function () {
    if (this.timeout) clearTimeout(this.timeout); //Clear any timeouts
    this.timeout = null;
    if (this.authed != null && this.type == "sig") {
      this.peerObj.close();
    } else if (this.authed == "cli") {

      if (this.int != null) {
        clearInterval(this.int);
        this.int = null;
      }

      if (this.timeout != null) {
        clearTimeout(this.timeout);
        this.timeout = null;
      }

      try {
        this.close();
      } catch (e) {
        return;
      }

      delete clients[this.cliObj.ident];
    }
  });

  //Message handler
  ws.on("message", onWebSoc);
}

//Get object lenth
function len (o) {
  var count = 0;
  for (i in o) count++;
  return count;
}
